inline함수

만약 C언어에서 매크로 함수가 기억이 나지 않는다면
C언어 책으로 돌아가서 매크로 함수를 복습하고 보는게 좋다.

매크로함수는 치환을 하는 것이다
#define SQUARE(x) ((x)*(x))
SQUARE를 보면 ((x)*(x))로 치환하는 것이다.
std::cou<< SQUARE(5) << std::endl; 이
std::cout<< ((5)*(5)) << std::endl; 로 바뀌는 것이다.

장점: 함수가 인라인화 되어 성능의 향상으로 이어질 수 있다.
단점: 함수의 정의 방식이 일반함수에 비해서 복잡하다. 따라서 복잡한 함수의 정의에는 한계가 있다.

이 장점을 취하면서 단점을 해결할 수 있지 않을까 하면서 만들어 진것이
인라인 함수이다.

inline int SQUARE(int x)
{
	return x*x;
}

std::cou<< SQUARE(5) << std::endl;

이런 밑에 함수호출을 함수의 몸체로 바꾸고 싶다면
함수 앞에 inline을 붙인다.
이러면 함수의 호출로 인한 스택의 할당과 반환이라는 과정을 생략할 수 있다.
일반적으로 정의 하듯이 함수를 만들고 inline만 적으면 되기 때문에
복잡한 함수에도 사용할 수 있다.

하지만 여기서 다른 것이 있다.
매크로 함수는 선행처리기이다. 구문구문을 나눠서 괄호를 쳐줄수 밖에 없었다.
하지만 인라인함수는 컴파일러에 의해 처리가 되기 때문에 괄호를 열고 닫는 걸 하지 않아도 된다.

매크로 함수의 단점은 디버깅이 어렵다.
왜냐하면 치환된 상태로 컴파일이 되기 때문에 거기서 디버깅을 하여서
디버깅을 할 때 어렵다.
하지만 인라인함수는 컴파일러가 처리를 하기 때문에
에러가 왜 일어났는지 더 쉽게 알 수 있다.
그래서 디버깅이 용의하다.

정리를 해보자면
매크로 함수는 선행처리기가 처리를 하고
인라인 함수는 컴파일러에서 처리를 한다.

요즘 컴파일러는 좋아졌기 때문에 inline함수를 쓰면
그냥 변하는 것이 아니라 컴파일러에게 이걸 inline으로 써도 되겠니 물어보고
써도 됨 하면 인라인화 되고 안되면 인라인화가 되지 않는다.
그리고 만약 inline을 적지 않더라도 컴파일러가
이 함수는 인라인화를 하는 것이 좋겠다 하면
inline화를 시켜 버릴 수도 있다.

매크로 함수만의 장점으로는
자료형에 독립적이다.
하지만 인라인 함수는 자료형을 명시해야한다.
그래서 필요한 자료형으로 만들어서 오버로딩 해야 하는 단점이 있지만
c++에서는 탬플릿이라는 방법으로 해결을 한다
이 탬플릿은 나중에 배운다.
지금은 탬플릿으로 해결 한다는 점만 기억을 하자
