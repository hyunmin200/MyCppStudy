함수 오버로딩

c에서는
int MyFunc()
{
}
int MyFunc(int num)
{
}
이렇게 두개를 선언을 하면 컴파일 에러가 난다.
동일한 내용의 함수가 두개가 있기 때문에 호출하지 못한다.

우리는 여기서 저걸 왜 구분을 못할까? 라고 생각할 수 있다.

MyFunc(5); 이러면
두 번째 함수를 호출하라는 뜻이다.
MyFunc(); 이러면
첫 번째 함수를 호출하라는 뜻이다.
이러면 우리는 알아볼 수 있다.
하지만 컴파일러는 허용하지 않는다
왜냐하면 C언어는 함수를 호출할 때에는 오직 이름만 본다.
MyFunc(5)를 찾아가야지가 아니라 MyFunc라는 이름을 찾아가서 두 개가 있네
하고 에러를 내는 것이다.

근데
5라는 인자값을 가질 수 있는 MyFunc를 찾아보자 하면 된다.
그래서 호출한 함수를 찾을 때 (이름 + 인자)를 다 본다면 구분을 할 수 있다.
바로 이 개념을 적용한 것이 함수 오버로딩이다.
c++에서는 함수를 찾을 때 (이름 + 인자)로 찾아서 오류가 나지 않는다.

int MyFunc(int num)
{

}

int MyFunc(int a, int b)
{

}
이렇게 있을 때 인자값의 자료형을 같아도 개수가 다르면 구분이 된다.
이러한 형태의 함수정의를 가리켜 '함수 오버로딩(FunctionOverloading)'이라 한다.

오버로딩의 예

int MyFunc(char c) {...}
int MyFunc(int n) {...}
매개변수의 자료형이 다르므로 성립

int MyFunc(int n) {...}
int MyFunc(int n1, int n2) {...}
매개변수의 수가 다르므로 성립

void MyFunc(int n) {...}
int MyFunc(int n) {...}
반환형의 차이는 함수 오버로딩의 조건을 만족시키지 않음;
