int iStatus는 32비트임
32비트로 어떤 특정 상태를 표현 할 수 있음
경우의 수를 이야기 하는 것이 아님

32비트를 가지고 특정상태를 표현하는 것이다 여기서 말하는 상태는 조합이 되는 것이다.
여러가지의 상태(독에 걸렸다 안걸렸다. 데미지를 입었다 안입었다.)이런 상태를 나타내기 위해서는
겹치지 않는 자리가 필요하다.
비트수가 32개 이기 때문에 우리는 32가지의 상태를 한 번에 나타 낼 수 있다.
첫 번째 칸 ....x에 HUNGRY가 들어 있다고 치자
여기서 HUNGRY가 들어가 있는 자리가 1이다 그러면 배고픈 상태이고 0이면 안고픈 상태인 것이다.
이런 것이 총 32개가 있는 것이다. unsigned int 는 즉 32가지의 상태를 동시에 나타낼 수 있는 것이다.

예를 들자면
첫 번째 칸에 HUNGRY
두 번째 칸에 THIRSTY
세 번째 칸에 TIRED 
이렇게 있다면 define으로 선언할 때
헝그리는 1
떨스티는 2
타이얼드는 4를 해주어야 한다.
왜냐하면 비트 연산자의 3번째 칸에 들어가야하는 1이기 때문에 4가 된다.

상태를 넣을 때는 이런 식으로 넣는다
#define HUNGRY  1
#define THIRSTY 2

unsigned int iStatus = 0;

iStatus |= HUNGRY;
iStatus |= THIRSTY;
비트합을 쓰면 위에 1인것은 그대로 1로 내려오고 0인 것은 아래가 1이 아닌이상 그냥 내려오기 때문에 유동적으로 바꿀 수 있다.
0100 1010
1010 0000 이거 두개를 비트합을 해보면
1110 1010 이렇게 위에것은 유지가 되면서 활성활를 시킬 수 있다.

상태를 조건으로 확인 할 때는
if(iStatus & THIRSTY)
{

}
이런 식으로 확인을 하면 된다 비트곱이기 때문에
iStatus가 아무리 1110 1110 이런 식으로 되어있다 해도
THIRSTY가 0000 0010 이면 결국 다 0000 0010 에 1부분이 둘 다 1이면 참이기 때문에
THIRSTY가 참이 되면 결국 iStatus도 참이 되어서 조건에 걸리게 된다.
만약 내가 목이 안말라서 1110 1100이라면 0000 0010 이랑 비트곱을 하였을 때
둘 다 1이 아니기에 0000 0000이 되어 거짓이 된다.
그래서 이런 식으로 if문 안에 코드를 넣어서
만약 뭐 화상 상태라면 초마다 데미지를 10씩 준다. 이런식으로 코드를 이행 시킬 수 있다.

만약 상태를 빼주고 싶다면 xor연산을 사용하여서 빼줄 수 있다.
예를 들어
1101에 중간에 1을 빼고 싶다면
0100을 해주어 xor특징으로 같은면 0 다르면 1이기 때문에
딱 빼주고 싶은 것만 빼줄 수 있다.

하지만 이것은 문제가 있다
만약 니가 피곤하다면 이제 충분히 쉬었을니까 피곤함 디버프를 없애!라는 코드를 짜서 실행을 계속 돌리는데
애초에 피곤하지 않았다면
0000 맨 오른쪽이 피곤함이라고 할 때
0001 을 xor연산을 해주면
0001 이 되어 피곤하지 않았는데 피곤함을 얻을 수 있다.
그래서 xor을 사용하려면 만약 너가 피곤하다면 이런 코드를 실행해라..이런 식으로..비교연산을 해줘야 한다.
그리고 애초에 비트를 뺄 때는 xor을 사용하지 않는다.

비트를 뺄 때는
iStatus &= ~THIRSTY; 이런 식으로 사용한다
비트 곱 연산을 하기전에 반전을 시켜버린다.
이게 어떤 식으로 작동하는지 알아보자.

1110 1010 여기서 오른쪽에서 두번째가 목마름이라고 하고 빼보자 그러면
0000 0010 여기서 비트 반전을 먼저 해준다 그러면
1111 1101 이 된다. 그래서 여기서 비트곱을 해주면

1110 1010
1111 1101 이 되는데
비트곱은 원래 둘 다 1이 아니면 0이 되는데 반전을 하고 비트곱을 사용하면
원래 1이였던 것들은 1로 0이였던 것들은 0이되어 자신이 빼고 싶은 것이 0이랑 1이 만나기 때문에 뺄 수 있다.
iStatus &= ~THIRSTY; 이런 식 앞으로 코드를 보다보면 나올테니 기억을 해두는 것이 좋다.

특정 상태에 해당하는 것은 2의 승수로 올라가는 것을 알 수있다.
#define FIRE	8 //네 번째 자리
#define COLD	16 //다섯 번째 자리
이런 식으로 2의 승수로 올라감

하지만 보통 16진수로 쓴다고 한다.
16진수를 c++에서 적을 때는 0x를 사용함
#define HUNGRY  0x1
#define THIRSTY 0x2
#define TIRED   0x4
#define FIRE	 0x8
#define COLD	 0x10
이런식으로 쓰임 F가 15이기 때문에 0x10임
그리고 16진수가 편한 이유가 계속 이런 식으로 반복이 된다.

#define HUNGRY  0x001
#define THIRSTY 0x002
#define TIRED   0x004
#define FIRE	 0x008

#define COLD	 0x010
#define POISON  0x020
#define COLD1	 0x040
#define POISON1 0x080

#define COLD2	 0x100
#define POISON2 0x200
#define COLD3	 0x400
#define POISON3 0x800
그래서 코드를 볼 때 보통 이런식으로 되어있음
코드 같은 것들은 이제 다른 상태로 원래 나타내야함

그럼 정리를 해보자면
// 상태추가
iStatus |= HUNGRY;
iStatus |= THIRSTY;

// 상태 확인
if (iStatus & THIRSTY) {

}

// 특정 자리 비트 제거
iStatus &= ~THIRSTY; 
이렇게 된다

그리고 이 비트연산자가 게임 뿐만아니라 많이 쓰인다.
윈도우 프로그래밍을 할 때는 x 최대/최소화 이런것을 다 상태값으로 만들어 놨다.
이렇게 만들면 좋은 점이 나중에 함수를 배우는데 함수에 인자를 전달 해줄 수 있다.
윈도우 창 하나를 만드는 것이면 그것을 전달 받을 께 엄청나게 많다.
닫기, 최소화 어떤 크기 이런 것들.. 이런 걸 입력받으려면 너무 많다
근데 애는 상태값 하나만 요구를 한다. 그 상태값안에는 
이 윈도우가 child스타일 인지 아닌지 0, 1 x버튼을 추가 할 것인지 0, 1 최대 최소 버튼 추가 할 건지 말지 0, 1
이런 상태들을 변수에 넣어놓고 한 번에 전달을 해주는 것이다.

그럼 그안에 최대 그 비트의 수만큼 상태가 내포되어 있는 것이다.
그래서 그 상태값을 받았을 때 그걸 하나하나 검사하면서 구현을 하는 것이다.
여기서 비트연산이 많이 들어간다.

그리고 게임 쪽에서도 캐릭터의 상태를 구현하는데 많이 쓴다.
그래서 메모리를 조사 해보면 캐릭터 상태값이 64비트나 32비트로 되어서
비트자리로 마킹이 되어있다.