비트 연산자
이거 자주 까먹기 쉽기 때문에 자주 보고 상기 시키기
비트단위로 연산이 진행 될 때 사용함
쉬프트 <<, >> 비트를 화살표로 가리키는 방향으로 한 칸 씩 민다.

1바이트 변수
unsigned char byte = 1;
0000 0001 (1)

byte << 1; 왼쪽으로 비트를 한 칸 밀겠다는 소리
0000 0010 비트가 이렇게 됨
그러면 값은 2가 됨 즉 2진수 이기 때문에 2배 증가함
왜 인지 쉽게 이해 시켜보자면
10진수에서는 02 가 한 칸 왼쪽으로 밀려나면 20 즉 10배가 증가한다.
그러므로 2진수에서는 01(1)이 한 칸 왼쪽으로 밀려나면 10(2) 즉 2배 증가 되는 것이다.

비트 중에 0000 1010 있다고 하자 10진수로는 10이다.
애네가 한 칸 식 왼쪽으로 가면 0001 0100 즉 2배가 되어 10진수로 20이 나온다.

이것도 연산자 처럼 생각해서
byte <<= 1; 또는 byte = byte << 1; 이렇게 한 칸 민 값을 넣어 줄 수 있다.

그리고
unsigned char byte = 10;
byte <<= 2; 이라고 하면 두 칸 미는 것 즉 4배가 되는 것

byte <<= 3; 이라고 하면 세 칸 미는 것 즉 8배가 되는 것이다.
byte <<= n;
딱 2의 n승 만큼 올라가는 것이다.

반대로 오른 쪽으로 민다면
unsigned char byte = 10;
byte >>= 1;
2분의1로 줄어들 것이다.

만약 unsigned char byte = 13; 이렇다면?
byte >>= 1; 이렇게 밀었을 때 어떻게 될 까?
홀수라는 것은 마지막 비트가 1인 것이다 그러므로 오른쪽으로 밀었을 때
1이 사라지게 된다 즉 2의 n승으로 나눈 몫만 취하게 되는 것이다.
0000 0001 이라면
0000 0000 이 되는 것
즉
byte <<= 1; 은 2^n 배수이고
byte >>= 1; 은 2^n 나눈 몫이다

만약 byte >>= 2 라면 두 칸을 오른쪽으로 민 것이기 때문에
0000 00xx 이 x비트 두개가 날라 간다고 볼 수 있다.

비트 곱(&), 합(|), xor(^), 반전(~)

비트간의 연산에서는 진짜 비트끼리 하나씩 하나씩 계산한다.
0100 1001
0100 0110
비트 단위 하나씩 맨 오른쪽 1하고 0  0하고 1 ....이렇게

그래서 여기서 곱(&)은
비트 단위로 둘 다 1일 경우 1 둘 중 하나라도 0이면 0 이런 것이다.

비트 합(|)은
비트 둘 중 하나라도 1이면 1이고 둘 다 1이 아니라면 0

비트 반전은 말 그대로 비트를 반전하는 것이다
1101 1110 이라는 비트가 있다면
0010 0001 이렇게 바꾸는 것이다.

xor(^)
각자리의 비트가 같으면 0 다르면 1이다.
1101 1110 이거랑
0010 0001 이렇게 반전 시킨거랑 xor연산을 한다면
1111 1111 이렇게 다 다르기 때문에 모두 1이 된다.

정리하면
& 둘다 1인 경우 1
| 둘중 하나라도 1 이면 1
^ 같으면 0, 다르면 1
~ 1은 0으로, 0은 1로

이걸 어디다가 쓰지? 할 수 있는데
게임에서도 활용도가 있다.

그걸 알기 전에 전처리기 매크로(구문) define을 알아보자
전처리기가 뭔지 모를 수 있는데 말 그대로 먼저 처리하는 것이다
#으로 작성된 전처리기 구문은 모든 컴파일 과정 중 제일 먼저 처리가 된다.

define이라는 구문은 내가 지정한 구문을 특정숫자로 치환을 해줌
함수 같은 느낌으로 쓸 수 있음
하지만 지금은 함수를 배우지 않았으니 치환한다는 기준에 집중을 한다.

#define HUNGRY 1
이렇게 작성을 한다고 치면
int iStatus = HUNGRY; 이런 코드를 짜면 1를 넣는 다는 것이다 누가봐도 1이 아니라고 할 수 있지만
위에 define이라는 전처리기 구문으로 HUNGRY를 숫자 1로 바꿔라 이런 것이다.
그래서 결국 컴파일을 할 때는 1로 적용이 되는 것이다.

그래서 define을 왜 쓸까?
2가지 장점이 크게 있다.

1. 
내가 iStatus 이 변수로 캐릭터의 상태를 나타낸다고 했을 때
상태는 여러가지가 있을 수 있다. 공격력 체력 방어력 화상 상태 배고픔 등등 이것들이 중첩되서 돌아갈 것이다.
근데 여기서 배고픔이 숫자 1이라는 것을 프로그래머가 암기하고 있어야 하는가?
여기에는 공격력을 31을 넣어줘야 해 이런 것들을 어떻게 암기를 할까? 그리고 나중에 31은 체력입니다. 이런 상태가 되면
심각해 질 수 있다.
즉 코드로 작성하기 때문에 가독성을 높일 수 있다. 

2. 
음 우리 HUNGRY를 3으로 바꿔야 되요 했을 때 문제가 없다.
내가 숫자를 1로 작성한 것이 아니라 HUNGRY로 작성하였기 때문에
모든 HUNGRY 값을 다 찾아서 3으로 바꿀 필요가 없는 것이다.

하나 예를 더 들어보자면
만약 내가 자판기 프로그램을 만들었다고 하였을 때
define으로 MAX_SIZE 20라는 코드를 작성해 코드를 작성했다면
다음에 더 큰 자판기로 만들 때 MAX_SIZE 40으로 바꿔주기만 하면 된다.
그래서 즉 유지 보수적으로 좋다.

