정적 변수

static 자료형 변수명 = 값;
이런식으로 사용함

정적 변수도 데이터영역을 사용한다.
근데 이러면 전역변수와 똑같을 것이라고 생각할 수 있다.

하지만 빌드를 하면 전역변수와 달리 정적변수는 문제가 없을 것이다.

정적이라는 의미를 잘 생각해보면 쉽게 사용할 수 있다.
안움직이는 변수?
c, c++에서 안움직이는 변수라는 것은 선언된 곳에서만 있는것이다.

main.cpp에 static변수를  선언하고 func.cpp에 static변수를 선언하면
main.cpp에 선언된 static변수는 거기서 계속 머물고
func.cpp에 선언됨 static변수도 거기서 계속 머문다.

이러면 이제 전역변수는 합쳐질 때 문제가 되었지만
정적 변수는 합쳐질 때 main에는 있는 것은 main에만 존제하고
func에 있는 것은 func에만 존재하기 때문에 에러가 나지 않는다.
왜냐? 각자 자기 파일 전용으로 선언된 애들이기 때문이다.

자기가 선언된 위치에서만 동작을 한다는 것을 기억한다면
스테틱이 어디에 선언되어도 우리는 생각을 할 수 있을 것이다.

static(정적 변수)가 함수안에 선언되는 경우가 있다.

void Test() {
	static int i = 0;

}

그럼 이 스텍티변수는 Test함수에 고정이  된 것이다.
일단 정적 변수이기 때문에 데이터영역을 사용한다.

그렇기 때문에 

void Test() {
	static int i = 0;
	
	int a = 0;
}
이면 a는 Test함수가 호출이 되는 순간에 호출스택에 만들어질 것이다.
근데 이 i는 호출스택에 포함이 되어 있지 않는다.

왜냐하면 데이터영역이기 때문이다.
근데 선언위치가 Test안쪽이기 때문에 Test함수에서만 사용이 가능하다.

바꿔말하면
정적변수를 특정함수안에 선언해 놨을 경우에 
그 해당 함수안에서만 사용이 가능하면서
그 함수가 종료되거나 호출되거나 할 때
스택메모리를 사용하지 않기 때문에
해당 함수의 호출과 종류의 따라서 생성되거나 해체되지 않고 
계속 유지되는 메모리이지만 사용은 그 함수에서만 사용할 수 있다.

어? 그럼 정적변수가 필요할까?

상시 유지시키고 싶으면 전역변수를 만들면 됬었다.
근데 정적변수에 특징으로는 딴 데서 사용을 못한다. 문법적으로 보았을 때
이것은 오히려 제안을 건것이 기능인 것이다.

내가 우리 프로그램을 실행하는 내내 Test라는 함수가 몇번 호출되었는지 테스트를 하고 싶다.
그래서 Test함수가 호출될 때마다 전역변수의 숫자를 증가 시킬 것이다.
근데 실수로 전역변수인 g_i를 잘 못해서 0으로 초기화 시킨다면 테스트가 오류가 날 수도 있는 것이다.

하지만 이제 내가 만든 함수안에서만 사용을 하려고 정적변수를 선언한다면
코드를 수정하지 않는한 정적변수를 다른데서 접근할 방법이 없다!

이렇게 기능을 제안하고 접근을 제한하는거 조차도 기능이다.

함수안에 정적 변수를 선언을 하면은 호출될 때마다 저 값을 넣는 다는 것이 아니라
이 함수에서만 접근가능한 정적변수의 초기값을 0을 주겠다는 뜻이고
그 다음부터는 초기화 부분이 초기화 되지 않는데
최소 초기화후 저 초기화문이 건너뛴다.

함수의 호출과 종료에 상관없이 프로그램 실행 내내 유지시킬 수 있는 데이터영역의 들어간
변수를 만들고 싶을 때 정적변수를 사용한다.


하지만 우리가 원하는 것은 이것이 아니다.

common.h를 만들어 정적변수를 넣어주고
다른 파일에 #include를 다 넣어준다.
이러면 처음에 했던것과 똑같은거 아닌가? 라고 할 수 있는데
맞다 이러면 처음 정적 변수를 사용했던것과 똑같다.

그럼 이제 여기서 필요한 것이 외부 변수이다.
extern 자료형 변수명; (헤더에 만들 때 값을 넣으면 안된다.)

entern은 변수가 있다는 것을 알려주는 것이다. (실제 존재 X)
그럼 각 파일들은 entern변수가 있다는 것을 알 수 있다.

그래서 사용하기 위해서는 아무 cpp파일에서 자료형 변수명으로 초기화를 해줘야지 사용을 할 수 있다.
그래야지 합쳐질때 연결이 되기 때문이다.