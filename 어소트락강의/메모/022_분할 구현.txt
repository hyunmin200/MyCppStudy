정적 변수와 외부 변수를 설명하려면 파일의 분할 구현을 알고 있어야 한다.
헤더 파일과 cpp파일을 분리해서 구현을 하는 것이다.

헤더랑 파일을 왜 분리할까?

일단 헤더랑 CPP를 만들어서 사용해보자

헤더에서는 사용하는 함수를 적는다.
여기서 내가 헤더에서 함수를 구현을 하지 않는다고 하면
int Add(int a, int b);
이런식으로 정의하지 않고 선언만 할 수 있다.

왜 이런 행동을 하는가?

코드는 순차적으로 읽기 때문에
함수를 아래에 선언을 해버리면 함수를 찾을 수가 없었지만
헤더에서 선언을 미리 해두면 컴파일 단계 중 하나인 링크 단계에서
함수가 아래 있다는 것을 알기 때문에 다 잡아준다.

만약 선언만 하고 정의를 하지 않는다면
LNK오류가 난다 (링크 단계에서 난 오류)
오류의 시점을 발견하는 것도 중요함
K = 100;을 해버리면
C숫자 오류가 나는데
이것은 컴파일 에러이다.

LNK오류가 난다면
컴파일(문법적 오류)는 넘어갔지만
링크단계에서 오류가 뜬 것이다.

근데 이게 무슨 상관이냐?
이때 헤더에서 선언한 것을 cpp에서 정의하는 것이다.

이 과정에서 #include를 사용하는데
#include는 전처리기 인데
#include 뒤에 명시한 파일을 복붙하는 것이다.

그럼 이제 main에 #include "func.h"를 쓰면 함수가 사용이 가능하다.
근데 여기서 헤더파일에는 선언만 했는데 어떻게 사용할 수 있냐? 라고 할 수 있다.
이때 우리는 func.cpp에 함수를 정의하였기 때문에
실행시키면 컴파일과정에서는 오류가 없어서 넘어간다.
그리고 나중에 이 모든게 합쳐져서 exe파일이 될 것이다.
그 exe(프로그램)안에는 내가 파일을 따로따로 구현을 했지만
내가 원하는 모든 기능이 하나로 합쳐지는데 여기서 확인을 한다.
그리고 링크과정에서  인식을 하고 하나로 합쳐질 때 
호출할 수 있도록 완전히 합쳐준다.

그래서 어딘가에 함수의 실제 구현이 되어있어야한다.

그럼 이제 본론으로 들어가서
왜 헤더랑 cpp를 구분해서 구현을 하는가?

이제 헤더만 불러오면 거기 있는 함수들을 쓸 수 있기 때문도 있고
이제 각각의 기능들을 모듈화 시켜놓는다면 
헤더파일만 필요할 때 불러와서 코드도 짧아져서 가독성도 좋아지고
다시칠 필요없이 편리하게 사용할 수 있다.

즉!
우리가 코드를 손쉽게 관리하기 위해서 이다!

이제 모든 코드를 다 메인함수에 구현한다고 생각을 해봐라
지금은 괜찮을지 몰라도 나중에 규모가 조금만 커지면
유지보수면에서 불편할 것이다.

하나의 파일에 짜는것이 성능적으로는 좋지만 
우리는 사람이기 때문에 정리를 하지 않는다면 나중에 힘들어 질 것이다.

이렇게 헤더랑 파일을 분리해서 구현하다보면
몇가지 문제점이 생긴다.
전역변수에서 문제점이 생김.

