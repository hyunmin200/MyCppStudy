비트 연산자
이거 자주 까먹기 쉽기 때문에 자주 보고 상기 시키기
비트단위로 연산이 진행 될 때 사용함
쉬프트 <<, >> 비트를 화살표로 가리키는 방향으로 한 칸 씩 민다.

1바이트 변수
unsigned char byte = 1;
0000 0001 (1)

byte << 1; 왼쪽으로 비트를 한 칸 밀겠다는 소리
0000 0010 비트가 이렇게 됨
그러면 값은 2가 됨 즉 2진수 이기 때문에 2배 증가함
왜 인지 쉽게 이해 시켜보자면
10진수에서는 02 가 한 칸 왼쪽으로 밀려나면 20 즉 10배가 증가한다.
그러므로 2진수에서는 01(1)이 한 칸 왼쪽으로 밀려나면 10(2) 즉 2배 증가 되는 것이다.

비트 중에 0000 1010 있다고 하자 10진수로는 10이다.
애네가 한 칸 식 왼쪽으로 가면 0001 0100 즉 2배가 되어 10진수로 20이 나온다.

이것도 연산자 처럼 생각해서
byte <<= 1; 또는 byte = byte << 1; 이렇게 한 칸 민 값을 넣어 줄 수 있다.

그리고
unsigned char byte = 10;
byte <<= 2; 이라고 하면 두 칸 미는 것 즉 4배가 되는 것

byte <<= 3; 이라고 하면 세 칸 미는 것 즉 8배가 되는 것이다.
byte <<= n;
딱 2의 n승 만큼 올라가는 것이다.

반대로 오른 쪽으로 민다면
unsigned char byte = 10;
byte >>= 1;
2분의1로 줄어들 것이다.

만약 unsigned char byte = 13; 이렇다면?
byte >>= 1; 이렇게 밀었을 때 어떻게 될 까?
홀수라는 것은 마지막 비트가 1인 것이다 그러므로 오른쪽으로 밀었을 때
1이 사라지게 된다 즉 2의 n승으로 나눈 몫만 취하게 되는 것이다.
0000 0001 이라면
0000 0000 이 되는 것
즉
byte <<= 1; 은 2^n 배수이고
byte >>= 1; 은 2^n 나눈 몫이다

만약 byte >>= 2 라면 두 칸을 오른쪽으로 민 것이기 때문에
0000 00xx 이 x비트 두개가 날라 간다고 볼 수 있다.

비트 곱(&), 합(|), xor(^), 반전(~)

비트간의 연산에서는 진짜 비트끼리 하나씩 하나씩 계산한다.
0100 1001
0100 0110
비트 단위 하나씩 맨 오른쪽 1하고 0  0하고 1 ....이렇게

그래서 여기서 곱(&)은
비트 단위로 둘 다 1일 경우 1 둘 중 하나라도 0이면 0 이런 것이다.

비트 합(|)은
비트 둘 중 하나라도 1이면 1이고 둘 다 1이 아니라면 0

비트 반전은 말 그대로 비트를 반전하는 것이다
1101 1110 이라는 비트가 있다면
0010 0001 이렇게 바꾸는 것이다.

xor(^)
각자리의 비트가 같으면 0 다르면 1이다.
1101 1110 이거랑
0010 0001 이렇게 반전 시킨거랑 xor연산을 한다면
1111 1111 이렇게 다 다르기 때문에 모두 1이 된다.





